# C언어 실습을 마치며

## 지난 4주를 돌아보며

C언어 실습 과정이 끝났다.  
단순히 C언어를 배우는 것 이상으로 DB가 차용하는 자료구조와 메모리 할당 방식, 웹서버의 통신에 대해서 알 수 있는 시간이었다.

정글에 입소한 뒤로 컴퓨터 공학 전공의 친구들로부터 C언어의 악명은 익히 들었다.
그들이 학부 시절 겪은 좌절과 혼란을 몇 주간 들어온 터라 겁이 났다.

자료구조/알고리즘 과정 마지막 주차에 반나절 시간을 할애하여 [TCP School의 C언어 파트](https://www.tcpschool.com/c/intro)를 일독했다.
다행이 구조체나 포인터와 배열, 비트 연산을 제외하고는 흐름을 이해하는데 큰 무리가 없었다.
특히 악명 높은 포인터도 개념 자체는 금방 받아들일 수 있었다. 

반에서 C언어 초보를 위한 스터디가 열려 한번 정도 참여했다.
준혁이가 학부 시절, C언어 강의자료를 제공해줘서 1주차에 풀었던 브론즈 등급의 백준 문제를 함께 풀며 손을 풀었다.
그때까지만 해도 생각보다 할 만하다고 느꼈다.
윤년이나 점찍기 풀이 결과 PYTHON과 엄청난 차이가 나 새삼 C언어의 위력을 느낄 수 있었다.
(윤년 기준) 메모리: 1,112KB ⚔️ 32,412KB / 시간: 0ms ⚔️ 40ms

C언어 5일차 연결 리스트에서 이중 포인트에 발목이 잡혀 시간을 상당히 지체했다.
과정이 끝나고 가장 공감이 되는 것은 민석이가 포스트한 '포인터는 어렵지 않습니다. 죽도록 헷갈릴 뿐입니다'에 백분 공감했다.
특히 실습을 위해 제공되는 코드에는 처음 보는 매크로(#define)이며 컴파일을 위한 헤더(#include) 등 초보자에게 난해한 코드로 가득했다.
뿐만 아니라 비트 연산은 초반에 이해가 상당히 어려웠다. 그런데 이해하고 나니 새로운 길이 열렸다. 그렇다고는 해도 내가 적극적으로 활용할 수 있는 것은 아니고, 단순히 훨씬 성능 좋은 연산 방식을 이해할 수 있는 정도다. 하지만 파이썬에서 튜플로 두개의 인자를 관리하던 것을 이제는 상위 비트, 하위 비트로 나눠서 단 16비트에 한 번에
인자를 삽입하고, 조회할 수 있게 되었다.


자료구조/알고리즘 과정이 끝날 때 해당 과정으로 무엇을 남겼어야 하는 질문을 스스로에게, 그리고 8기 소통방 채널에 했다.
그때 ChatGPT의 답변에 느낀 바가 있어 이번에는 C언어 실습 과정의 시작과 함께 물어봤다.
특히 C언어 개발 환경 자체가 현업에서는 드물기 때문에 해당 과정을 통해 시간이 흘러도 남겨야 하는 바가 무엇인지 명확히 하고자 질문을 몇 번이나 고쳤다.
그 중 가장 가슴에 와닿았던 부분은 디버깅 경험이었다.
파이썬, 자바와 달리 C언어 특성 상 세그멘테이션 폴트와 같은 메모리 관련 에러부터 자잘한 문제 발생이 잠재되어 있고, 디버깅도 쉽지 않다.
때문에 해당 과정 동안 코드의 오류를 직접 찾고 해결해본 횟수가 쌓일 수록 어떤 문제가 발생했을 때 어디서부터 어떻게 접근할 지 감이 생기고, 디버깅 과정에서 코드를 한 줄 한 줄 살펴보며 프로그램이 어떤 흐름으로 동작하는지 명확히 이해할 기회로 동작한다.
이러한 경험이 누적되면 코드를 작성하면서부터 에러를 사전에 방시할 수 있는 능력이 생기고, 디버깅 과정에서 IDE에서 제공하는 브레이크 포인터나 변수 상태 모니터링 기능을 숙련하면 다른 언어, 프레임우크에 적응할 때도 문제를 추적하는데 속도가 붙는다.

알고리즘 문제를 풀때와 달리, 내가 짠 코드가 정답인지 반례는 무엇인지 알수 없는 상태가 되자, 일단 코드를 짜고 나면 GPT에게 던져주어 자잘한 디버깅까지 위임했던 것이 배움의 기회를 크게 놓칠 수 있다는 것을 깨달았다.

그리고 C언어부터는 정글에서 제공하는 DOCKER로 진행하게 되었는데 DOCKER 외에도 실행을 위한 다양한 방식의 환경 세팅이 존재했고, 각각의 방식은 처음 보는 개념들로 가득했다.
DEVOPS를 전혀 모르는 나로서는 처음으로 벽을 마주한 느낌도 들었다.
분야가 너무 방대했고, 경험도 없던 터라 LLM이 써주는 명령어도 이해를 못하고 단순히 복붙만 하는 스스로를 보며 이래도 되는 걸까, 하는 의심이 들었다.

첫 주차에 자료구조를 C언어로 짜며 재귀함수를 새삼 공부하고 진도도 처음으로 82%를 달성하며 한껏 올랐던 자신감은 RED-BLACK TREE에서 많이 무너졌다.
알고리즘 책을 읽지 않고 유투브 강의 영상에만 의존해서도 충분히 짤 수 있다고 생각했던 게 후반부로 갈수록 디버깅이 전혀 안되는 지경까지 다다랐다.
알고리즘 문제처럼 입력 케이스가 따로 없었기 때문에 직접 케이스를 만들어 테스트해봤는데 좀 더 복잡한 케이스에서 번번히 에러가 났다.

결국 끊었던 담배를 태우러 흡연장에 가서 301호에서도 혼자서 풀어보려 했던 교육생들이 결국 코드를 엎고 책의 의사코드를 따라 썼다는 이야기에 위안을 얻었다.
이러한 경험은 malloc에서도 똑같이 재현되었는데, 그럼에도 단순히 의사코드를 따라 쓰는 것보다 스스로 의사코드를 짜내어 코드를 쓴 것이 적어도 내가 작성한 코드와 설계한 구조에 대해서는 매우 정확하게 이해할 수 있는 장점이 있었다.

결국 힘들게 삽입까지 완료하고 나자 다시 C언어로 무언가를 구현하고 디버깅하는 것에 겁이 나서 삭제는 개념만 익히는 선에서 주차를 마무리했다.
다음날 아침 윤석이가 마지막 날 밤새 디버깅을 하다 성공했다는 이야기를 듣고 나서 마지막까지 딥다이브 하지 못한 것이 두고두고 후회로 남았다. 

개념 이해는 확실히 csapp 책만으로는 한계가 있었다. 
그런가하면 책으로는 도무지 이해가 가지 않던 가상 메모리의 개념을 널널한 개발자의 영상들을 2~3번씩 섭렵하고 나서 발표한 경험은 자신감 회복에 크게 도움이 되었다.
그리고 네트워크 역시 김영환의 네트워크 강의가 통신 방식이나 http 헤더문을 이해하는 데에 큰 도움이 되었다.
또 일요일마다 집으로 오고 가는 길에 꾸준히 시청하던 지옥에서 온 git도 모두 보았다.

가장 인상적이었던 건 클라이언트와 서버의 소켓이 각자의 버퍼에 내용을 채우고 읽는 과정을 디버깅하듯 파악하는 모습이었다.
결국 개념은 책과 영상으로 해도 직접 코딩하며 배워야 할 것은 디버깅을 통해 함수의 동작 원리를 파악하는 방법과 디버깅 툴에 대한 숙련도라는 점을 새삼 다시 생각했다.

웹서버를 구현할 때에는 와이프가 5월 연휴동안 본가와 처가를 다녀온 덕에 주말을 온전히 정글에서 보낼 수 있었다.
그런데 강의실에서 와이프가 업로드한 영상으로 서로의 모습을 보고 있자니, 좀 처연한 생각도 들었다.







## 남기고 싶은 것들

### 경험



### 지식
#### C언어
- Segmentation Fault
    - 대표적인 원인
        - ❌ NULL 포인터 역참조
        - ❌ 초기화 안 된 포인터 사용
        - ❌ 배열 범위 초과
        - ❌ free 후 접근
        - ❌ 함수에서 반환된 지역 변수 주소 사용

    - 발생 시 의심할 것 3가지
        - 포인터가 가리키는 곳이 유효한 메모리인지?
        - 해당 메모리에 쓰기/읽기 권한이 있는지?
        - 할당한 메모리의 경계를 벗어나지 않았는지?

    - 안전하게 코딩하는 습관
        - 포인터는 항상 초기화하고 사용
        - malloc 사용 시 NULL 체크

- void * 사용 시 주의점

- 함수 vs 매크로
    - 처리 시점
    - 타입 체크
    - 메모리 영향
    - 디버깅 용이성

- 컴파일 메시지
    - 1. ERROR (에러)
        - 의미: 컴파일이나 링크 실패를 일으키는 심각한 문제
        - 예시 
            - 문법 오류 (ex: 중괄호 {} 누락)
            - 타입 불일치 (ex: int를 char *에 대입)
            - 선언되지 않은 함수/변수 사용
            - 링커 오류 (undefined reference)

    - 2. WARNING (경고)
        - 의미: 코드가 컴파일은 되지만 위험하거나 이상한 부분이 있다는 알림
        - 예시
            - 대입 시 타입이 일치하지 않는 경우 (예: int를 char*에 대입)
            - 초기화되지 않은 변수 사용
            - 사용되지 않은 함수 매개변수
            - signed/unsigned 타입 혼합

    - 3. NOTE (참고)
        - 의미: ERROR나 WARNING 메시지와 관련된 추가 정보 

**포인터 연산**
```c
#include <stdio.h>
int main(int argc, char *argv[])
{
    int arr[2][3] = {1,2,3,4,5,6};
    int (*p)[3] = NULL;     // int 타입 3개를 가진 배열을 가리키는 포인터 선언 (*p[3]: int 타입을 가리키는 포인터 3개의 배열) 
    p = arr;

    printf("%d\n", *(p[0] + 1) + *(p[1] + 2));                // 8 (2+6)
    printf("%d\n", *(*(p + 1) + 0) + *(*(p + 1) + 1));        // 9 (4+5)

    char* str[2]; 
    str[0] = "hello!"; 
    str[1] = "jungler"; 

    // 아래 코드의 실행 결과를 생각해보세요.
    printf("1. %s\n", str[0] + 1);                            // ello!
    printf("2. %s\n", (str + 1)[0] + 2);                      // ngler   

    int z[2] = {10, 11};
    int *p = NULL;
    p = &z[1];
    *(&z[0] + 1) += 3;        // *P = 14

    return 0; 
}
```

#### 자료구조/알고리즘
- 백트래킹    
    - 백트래킹 기법 중 하나는 하향할 때는 아무 것도 하지 않다가 리프에 도달하고 나면 값을 올라가면서 비교/누적하기

- 위상정렬
- B트리
    - **BST ⚔️ B-TREE**
        - *'BST는 메모리에 살고, B-Tree는 디스크에 살아요.'*
            - **BST**: 메모리는 빠르니까 자식 2개라도 괜찮아! 
            - **B-Tree**: 디스크는 느리니까 한 번에 많이 읽자! 
                - 디스크는 데이터를 읽을 때 한 번에 한 바이트씩 읽지 않고, 몇 KB(보통 4KB~16KB) 단위(**블록**)로 조회 → 한 노드에서 여러 키를 한 번에 비교하면서, 다음 갈 방향을 단번에 정할 수 있어 디스크 접근 횟수가 확 줄어듦.  

문자열 탐색
- 트라이
- **KMP**
    - step. 1 PI 테이블을 생성하여 문자열 내에 접두어와 같은 문자열이 얼마나 연속적으로 있는지를 기록
    - step. 2 본문에서 비교 중인 문자가 틀릴 경우 해당 위치의 PI 테이블을 보고 이전에 계산된 접두어 길이만큼 점프

- **보이어-무어**
    - step. 1 문자열 패턴에 대응하는 skip 배열 생성
        - 각 문자마다 마지막 문자에서 떨어진 정도를 기록 / 마지막 문자와 패턴에 없는 모든 문자는 문자열 길이를 매칭 (switch문 활용)
    - step. 2 본문에 포인터를 이동시키며 마지막 문자를 기준으로 비교, 틀린 경우에 매핑된 숫자만큼 이동    



#### 컴퓨터 시스템
- 가상화 & 추상화
- 가상 메모리
    - 다중 레벨 페이지 테이블
        - 출현 배경
        - 가상 주소 구성 방식
    - 가상 주소 할당 이후 실제 물리 프레임 주소 할당 흐름
        - Copy On Write
    - 페이지 폴트 유형
    - Demand-Zero memory

- 예외 제외 흐름
    - 예외 테이블
    - 예외 분류     
        - 하위 유형별 예시
        - 시스템콜             
    - 시그널

- Garbage Collector
    - 개념
    - 장/단점

- 파일 데이터 구조
- 파일의 종류
- 경로 유형
- 파일의 열기, 닫기
- 파일의 읽기, 쓰기
  - 짧은 카운트
- 파일의 메모리 매핑과 해제

- 챕터 12.
    - 12.6 병렬성을 위해서 쓰레드 이용하기
        - 💡 동일한 연산을 수행하는 멀티 스레드 환경에서 공유 변수 접근 횟수와 부분합을 처리하는 방식에 따른 성능 비교






#### VS Code 활용법 연구
터미널에서 한 번에 여러 명령어 실행
- '&&'로 구분 (e.g. make clean && make && ./mdriver)

- 터미널에서 cd 입력 중에 tab으로 주소 자동 완성

- Git 주요 명령어: Source Control의 오버플로우 버튼 클릭
- 브랜치 이동: 좌측 하단에 브랜치명을 클릭

- 똑같은 변수명에 멀티 커서 생성 : Ctrl + D (단축키 입력 시 순차적으로 커서 +1 생성)

- 단축키
  - Ctrl + B: 좌측 패널 열기/닫기
  - Ctrl + J: 하단 패널 열기/닫기
  - Ctrl + Shift + `: 현재 작업 폴더에서 터미널 열기
  - Ctrl + Shift + P : 현재 워크 스페이스에서 문자열 검색 (파일 검색 X)
  - Ctrl + P : 현재 파일에서 문자열 검색
  - : 파일 검색

#### Git/GitHub 학습
- 노션에 모두 정리

- Github 협업하기
  1. 원격 repo(Github) > settings > collaborators에서 추가
  2. push하기 전에 pull(fetch + merge)해서 최신 상태로 업데이트
    - Git Graph에서 브랜치에서 우클릭 후 다양한 Git 명령어 수행 가능
  3. 최신 상태로 업데이트한 브랜치의 작업 내역을 push
    - Sync Changes: pull + push (2번, 3번을 한 번에 실행)

#### 기타
- LLM을 쓰는 법
[AI시대 창의력 훈련법](https://youtu.be/rSS5yM74zeo?si=Qn5zXQ2pCp7WRk9U)

디버깅 요령
- assert를 이용한 디버깅
- 브레이크 포인트와 WATCH 패널을 이용한 디버깅
- 로그 파일 생성
```c
./mdriver -V > log.txt // 로그 파일 만드는 법
```
- 조건부 브레이크 포인트
    - 중단점에 우클릭 후 Expression 작성

#### 상기 항목들
[scanf() 함수](https://www.tcpschool.com/c/c_intro_scanf)