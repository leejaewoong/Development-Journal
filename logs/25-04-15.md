→ ↓ ↔ ❓ ✔️ ⏲️ 🗓️ ⚔️ 💡 🔥 😭 👏 🎵 

## 🧠공부 흐름
⏲️**21:32** 이번 C언어 과정을 통해 길러야 하는 능력을 ChatGPT에게 물어봤다. 디버깅을 통한 성장 기회를 놓쳐버렸다는 생각이 든다. 그동안 ChatGPT에게 자잘한 디버깅을 떠넘긴 것이 큰 실수로 느껴져 앞으로는 일정 시간까지는 혼자서 해보려 한다.  

## ⚙️C 학습
```c
#include <string.h>
strncpy(str1, str2, len)
strncat(str1, srt2, len)
strncmp(str1, str2, len)
```

## 🗃️자료구조/알고리즘
- **BST ⚔️ B-TREE**
    - *'BST는 메모리에 살고, B-Tree는 디스크에 살아요.'*
        - **BST**: 메모리는 빠르니까 자식 2개라도 괜찮아! 
        - **B-Tree**: 디스크는 느리니까 한 번에 많이 읽자! 
	        - 디스크는 데이터를 읽을 때 한 번에 한 바이트씩 읽지 않고, 몇 KB(보통 4KB~16KB) 단위(**블록**)로 조회 → 한 노드에서 여러 키를 한 번에 비교하면서, 다음 갈 방향을 단번에 정할 수 있어 디스크 접근 횟수가 확 줄어듦.  

- **KMP**
    - step. 1 PI 테이블을 생성하여 문자열 내에 접두어와 같은 문자열이 얼마나 연속적으로 있는지를 기록
    - step. 2 본문에서 비교 중인 문자가 틀릴 경우 해당 위치의 PI 테이블을 보고 이전에 계산된 접두어 길이만큼 점프

- **보이어-무어**
    - step. 1 문자열 패턴에 대응하는 skip 배열 생성
        - 각 문자마다 마지막 문자에서 떨어진 정도를 기록 / 마지막 문자와 패턴에 없는 모든 문자는 문자열 길이를 매칭 (switch문 활용)
    - step. 2 본문에 포인터를 이동시키며 마지막 문자를 기준으로 비교, 틀린 경우에 매핑된 숫자만큼 이동          

## 📌기타
**디버깅 과정 자체가 "언어와 시스템의 원리"를 학습하는 기회다**
- IDE가 보여주는 에러 메시지, 출력 값 로그, 콜 스택 등을 해석하다 보면, C나 컴퓨터 시스템의 내부 구조도 자연스레 이해  

**디버깅 툴과 친해질수록 장기적으로 개발 속도가 빨라진다**
- gdb나 lldb 같은 CLI 디버거를 사용할 줄 알게 되면, 문제가 생겨도 빠르게 원인 추적 가능  

**디버깅에 능숙해지면 문제를 "예측"하기도 쉬워진다**
- 실제로 여러 번 디버깅을 거치다 보면, “아, 여기서 뭔가 포인터가 잘못될 가능성이 있겠구나” 같은 식으로 코드를 작성하면서부터 에러를 사전에 방지  
- 장기적으로 유지보수와 품질 향상 측면에서도 큰 이점  

