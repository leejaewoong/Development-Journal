# C언어 실습을 마치며

## 지난 4주를 돌아보며

C언어 실습 과정이 끝났다.  
정글에 입소한 뒤로 컴퓨터공학을 전공한 친구들로부터 학부 시절 C언어를 배우며 겪었던 좌절과 혼란을 수없이 들어왔다.
지레 겁을 먹어서인지 자료구조/알고리즘 과정 마지막 주차에 반나절을 할애하여 [TCP School의 C언어 파트](https://www.tcpschool.com/c/intro)를 일독했다.
다행이 구조체나 포인터와 배열, 비트 연산을 제외하고는 흐름을 이해하는데 큰 무리가 없었다.
특히 악명 높은 포인터도 개념 자체는 금방 받아들일 수 있었다. 
과정이 시작되고 나서도 바로 학습 목표를 따라 진도를 나가지 않고 준혁이가 공유한 C언어 강의 자료를 보거나, 1주차에 풀었던 브론즈 등급의 백문 문제를 풀며 감을 익혔다.
윤년이나 점찍기 풀이 결과 PYTHON과 성능과 메모리 효율에서 엄청난 차이가 나 새삼 C언어의 위력을 느낄 수 있었다. (*윤년 기준 메모리: 1,112KB vs 32,412KB / 시간: 0ms vs 40ms)

이때까지만 해도 생각보다 할 만하다고 느꼈다.
하지만 3일 정도 지났을까, 연결 리스트에서 이중 포인트에 발목이 잡혀 시간을 상당히 지체했다.
과정이 끝나고 가장 공감이 되는 말 중에 하나가 '포인터는 어렵지 않습니다. 죽도록 헷갈릴 뿐입니다'이다.
뿐만 아니라 실습을 위해 제공되는 코드에는 처음 보는 매크로(#define)이며 컴파일을 위한 헤더(#include) 등 난해한 문법이 가득했다.
비트 연산 역시 이해가 상당히 어려웠다. 

거기에 더해 환경 설정에 관한 문제까지 가중되었다.
C언어 실습부터 실행 환경 세팅에 Docker를 포함한 다양한 선택지가 주어졌고, 각각의 방식은 처음 보는 개념들로 무엇부터 알아봐야 하는지 갈피를 잡을 수 없었다.
분야가 너무 방대했고, 경험도 없던 터라 LLM이 써주는 명령어도 이해를 못하고 단순히 복붙만 하는 스스로를 보며 이래도 되는 걸까, 하는 의심이 들었다.
프로그래밍 공부에 가장 큰 벽을 느꼈다고 해도 과언이 아니다.

이 때쯤 C언어 실습 과정에서 얻어야 하는 것이 무엇인지에 대해 ChatGPT에게 의견을 구했던 것 같다.
특히 C언어 개발 환경 자체가 현업에서는 드물기 때문에 해당 과정을 통해 시간이 흘러도 남겨야 하는 바가 무엇인지 명확히 하고자 질문을 몇 번이나 고쳤다.
그 중 가장 가슴에 와닿았던 부분은 디버깅 경험이었다.
파이썬, 자바와 달리 C언어 특성 상 세그멘테이션 폴트와 같은 메모리 관련 에러부터 자잘한 문제 발생이 잠재되어 있고, 디버깅도 쉽지 않다.
때문에 해당 과정 동안 코드의 오류를 직접 찾고 해결해본 횟수가 쌓일 수록 어떤 문제가 발생했을 때 어디서부터 어떻게 접근할 지 감이 생기고, 디버깅 과정에서 코드를 한 줄 한 줄 살펴보며 프로그램이 어떤 흐름으로 동작하는지 명확히 이해할 기회로 동작한다.
이러한 경험이 누적되면 코드를 작성하면서부터 에러를 사전에 방시할 수 있는 능력이 생기고, 디버깅 과정에서 IDE에서 제공하는 브레이크 포인터나 변수 상태 모니터링 기능을 숙련하면 다른 언어, 프레임우크에 적응할 때도 문제를 추적하는데 속도가 붙는다.
알고리즘 문제를 풀때와 달리, 내가 짠 코드가 정답인지 반례는 무엇인지 알수 없는 상태가 되자, 일단 코드를 짜고 나면 GPT에게 던져주어 자잘한 디버깅까지 위임했던 것이 배움의 기회를 크게 놓칠 수 있다는 것을 깨달았다.

그래도 첫 주차에 자료구조를 C언어로 짜며 재귀함수를 새삼 공부하고 진도도 처음으로 82%를 달성하며 한껏 올랐던 자신감은 RED-BLACK TREE에서 무너졌다.
알고리즘 책을 읽지 않고 유투브 강의 영상에만 의존해서도 충분히 짤 수 있다고 생각했던 게 후반부로 갈수록 디버깅이 전혀 안되는 지경까지 다다랐다.
알고리즘 문제처럼 입력 케이스가 따로 없었기 때문에 직접 케이스를 만들어 테스트해봤는데 좀 더 복잡한 케이스에서 번번히 에러가 났다.
결국 끊었던 담배를 태우러 흡연장에 가서 301호에서도 혼자서 풀어보려 했던 교육생들이 결국 코드를 엎고 책의 의사코드를 따라 썼다는 이야기에 위안을 얻었다.
어찌저찌 힘들게 '삽입'까지 완료하고 나자 다시 C언어로 무언가를 구현하고 디버깅하는 것에 겁이 나서 삭제는 개념만 익히는 선에서 주차를 마무리했다.
다음날 아침 윤석이가 마지막 날 밤새 디버깅을 하다 성공했다는 이야기를 듣고 나서 마지막까지 최선을 다하지 못한 것이 두고두고 후회로 남았다. 
시험 대신 공부한 것을 주제로 각자의 발표를 하는 목요일 아침을 지나면 심기일전으로 다시 힘이 솟았다, 화요일쯤 되면 스스로 구현 범위를 타협하는 과정이 반복되었다.

그러던 중 마지막 과정이었던 웹서버 구현 주차였다.
어느 새벽, 같은 조는 아니었지만 유진과 현호, 나만 교실에 남아 클라이언트와 서버의 소켓이 각자의 버퍼에 내용을 채우고 읽는 과정을 디버깅하듯 추적했다.
VS code의 VARIABLES와 WATCH 패널을 능숙하게 다루는 현호의 솜씨에 경외심을 느꼈다.
또 한편으로는 장님 코끼리 더듬듯 배워가는 식이었지만, 소켓 통신의 가장 말초적인 코드까지 들어가서 애쓰는 스스로가 대견하게 느껴졌다.
정글이 강조하는 학습의 태도와 방법을 몸소 익혀가고 있다는 느낌이 들었다.
연휴간 와이프가 올려준 서로의 영상을 강의실에서 보며 들었던 처연함이 조금은 씻겨져 내려간 듯했다.

이제 과정이 절반 정도 남았다.
29살에 UX를 처음 배웠을 때로 돌아간 듯한 시간 여행도 얼마 남지 않았다는 생각이 든다.
인생에서 다시는 겪지 못할 시절을 다시 보내는 행운을 충분히 누리고 싶다.


## 남기고 싶은 것들

### 경험



### 지식
#### C언어
- Segmentation Fault
    - 대표적인 원인
        - ❌ NULL 포인터 역참조
        - ❌ 초기화 안 된 포인터 사용
        - ❌ 배열 범위 초과
        - ❌ free 후 접근
        - ❌ 함수에서 반환된 지역 변수 주소 사용

    - 발생 시 의심할 것 3가지
        - 포인터가 가리키는 곳이 유효한 메모리인지?
        - 해당 메모리에 쓰기/읽기 권한이 있는지?
        - 할당한 메모리의 경계를 벗어나지 않았는지?

    - 안전하게 코딩하는 습관
        - 포인터는 항상 초기화하고 사용
        - malloc 사용 시 NULL 체크

- void * 사용 시 주의점

- 함수 vs 매크로
    - 처리 시점
    - 타입 체크
    - 메모리 영향
    - 디버깅 용이성

- 컴파일 메시지
    - 1. ERROR (에러)
        - 의미: 컴파일이나 링크 실패를 일으키는 심각한 문제
        - 예시 
            - 문법 오류 (ex: 중괄호 {} 누락)
            - 타입 불일치 (ex: int를 char *에 대입)
            - 선언되지 않은 함수/변수 사용
            - 링커 오류 (undefined reference)

    - 2. WARNING (경고)
        - 의미: 코드가 컴파일은 되지만 위험하거나 이상한 부분이 있다는 알림
        - 예시
            - 대입 시 타입이 일치하지 않는 경우 (예: int를 char*에 대입)
            - 초기화되지 않은 변수 사용
            - 사용되지 않은 함수 매개변수
            - signed/unsigned 타입 혼합

    - 3. NOTE (참고)
        - 의미: ERROR나 WARNING 메시지와 관련된 추가 정보 

**포인터 연산**
```c
#include <stdio.h>
int main(int argc, char *argv[])
{
    int arr[2][3] = {1,2,3,4,5,6};
    int (*p)[3] = NULL;     // int 타입 3개를 가진 배열을 가리키는 포인터 선언 (*p[3]: int 타입을 가리키는 포인터 3개의 배열) 
    p = arr;

    printf("%d\n", *(p[0] + 1) + *(p[1] + 2));                // 8 (2+6)
    printf("%d\n", *(*(p + 1) + 0) + *(*(p + 1) + 1));        // 9 (4+5)

    char* str[2]; 
    str[0] = "hello!"; 
    str[1] = "jungler"; 

    // 아래 코드의 실행 결과를 생각해보세요.
    printf("1. %s\n", str[0] + 1);                            // ello!
    printf("2. %s\n", (str + 1)[0] + 2);                      // ngler   

    int z[2] = {10, 11};
    int *p = NULL;
    p = &z[1];
    *(&z[0] + 1) += 3;        // *P = 14

    return 0; 
}
```

#### 자료구조/알고리즘
- 백트래킹    
    - 백트래킹 기법 중 하나는 하향할 때는 아무 것도 하지 않다가 리프에 도달하고 나면 값을 올라가면서 비교/누적하기

- 위상정렬
- B트리
    - **BST ⚔️ B-TREE**
        - *'BST는 메모리에 살고, B-Tree는 디스크에 살아요.'*
            - **BST**: 메모리는 빠르니까 자식 2개라도 괜찮아! 
            - **B-Tree**: 디스크는 느리니까 한 번에 많이 읽자! 
                - 디스크는 데이터를 읽을 때 한 번에 한 바이트씩 읽지 않고, 몇 KB(보통 4KB~16KB) 단위(**블록**)로 조회 → 한 노드에서 여러 키를 한 번에 비교하면서, 다음 갈 방향을 단번에 정할 수 있어 디스크 접근 횟수가 확 줄어듦.  

문자열 탐색
- 트라이
- **KMP**
    - step. 1 PI 테이블을 생성하여 문자열 내에 접두어와 같은 문자열이 얼마나 연속적으로 있는지를 기록
    - step. 2 본문에서 비교 중인 문자가 틀릴 경우 해당 위치의 PI 테이블을 보고 이전에 계산된 접두어 길이만큼 점프

- **보이어-무어**
    - step. 1 문자열 패턴에 대응하는 skip 배열 생성
        - 각 문자마다 마지막 문자에서 떨어진 정도를 기록 / 마지막 문자와 패턴에 없는 모든 문자는 문자열 길이를 매칭 (switch문 활용)
    - step. 2 본문에 포인터를 이동시키며 마지막 문자를 기준으로 비교, 틀린 경우에 매핑된 숫자만큼 이동    



#### 컴퓨터 시스템
- 가상화 & 추상화
- 가상 메모리
    - 다중 레벨 페이지 테이블
        - 출현 배경
        - 가상 주소 구성 방식
    - 가상 주소 할당 이후 실제 물리 프레임 주소 할당 흐름
        - Copy On Write
    - 페이지 폴트 유형
    - Demand-Zero memory

- 예외 제외 흐름
    - 예외 테이블
    - 예외 분류     
        - 하위 유형별 예시
        - 시스템콜             
    - 시그널

- Garbage Collector
    - 개념
    - 장/단점

- 파일 데이터 구조
- 파일의 종류
- 경로 유형
- 파일의 열기, 닫기
- 파일의 읽기, 쓰기
  - 짧은 카운트
- 파일의 메모리 매핑과 해제

- 챕터 12.
    - 12.6 병렬성을 위해서 쓰레드 이용하기
        - 💡 동일한 연산을 수행하는 멀티 스레드 환경에서 공유 변수 접근 횟수와 부분합을 처리하는 방식에 따른 성능 비교






#### VS Code 활용법 연구
터미널에서 한 번에 여러 명령어 실행
- '&&'로 구분 (e.g. make clean && make && ./mdriver)

- 터미널에서 cd 입력 중에 tab으로 주소 자동 완성

- Git 주요 명령어: Source Control의 오버플로우 버튼 클릭
- 브랜치 이동: 좌측 하단에 브랜치명을 클릭

- 똑같은 변수명에 멀티 커서 생성 : Ctrl + D (단축키 입력 시 순차적으로 커서 +1 생성)

- 단축키
  - Ctrl + B: 좌측 패널 열기/닫기
  - Ctrl + J: 하단 패널 열기/닫기
  - Ctrl + Shift + `: 현재 작업 폴더에서 터미널 열기
  - Ctrl + P : 현재 워크 스페이스에서 파일 검색
  - Ctrl + Shift + F : 현재 워크 스페이스에서 문자열 검색 (파일 검색 X)
  - Ctrl + F : 현재 파일에서 문자열 검색
  

#### Git/GitHub 학습
- 노션에 모두 정리

- Github 협업하기
  1. 원격 repo(Github) > settings > collaborators에서 추가
  2. push하기 전에 pull(fetch + merge)해서 최신 상태로 업데이트
    - Git Graph에서 브랜치에서 우클릭 후 다양한 Git 명령어 수행 가능
  3. 최신 상태로 업데이트한 브랜치의 작업 내역을 push
    - Sync Changes: pull + push (2번, 3번을 한 번에 실행)

#### 기타
- LLM을 쓰는 법
[AI시대 창의력 훈련법](https://youtu.be/rSS5yM74zeo?si=Qn5zXQ2pCp7WRk9U)

디버깅 요령
- assert를 이용한 디버깅
- 브레이크 포인트와 WATCH 패널을 이용한 디버깅
- 로그 파일 생성
```c
./mdriver -V > log.txt // 로그 파일 만드는 법
```
- 조건부 브레이크 포인트
    - 중단점에 우클릭 후 Expression 작성

#### 상기 항목들
[scanf() 함수](https://www.tcpschool.com/c/c_intro_scanf)